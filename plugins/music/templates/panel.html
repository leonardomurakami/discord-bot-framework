{% extends "plugin_base.html" %}

{% block extra_styles %}
/* Music plugin specific styling */
.music-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.75rem;
}

/* Hide music controls when no server selected */
.music-controls-hidden {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
}

.no-server-message {
    text-align: center;
    padding: 3rem 2rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: var(--card-radius);
    margin-bottom: 2rem;
}

.no-server-message h3 {
    color: var(--text-primary);
    margin-bottom: 1rem;
    font-size: 1.25rem;
}

.no-server-message p {
    color: var(--text-secondary);
    margin-bottom: 0;
}

.music-section {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: var(--card-radius);
    padding: 1.6rem 1.8rem;
    box-shadow: var(--shadow-sm);
}

.music-section h3 {
    margin: 0 0 1rem 0;
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.connection-details {
    margin: 0 0 1.2rem 0;
    color: var(--text-secondary);
    font-size: 0.9rem;
}

/* Modern Music Player Styling */
.current-track {
    background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(248, 250, 252, 0.95));
    border: 1px solid rgba(226, 232, 240, 0.8);
    border-radius: 20px;
    padding: 2rem;
    margin-bottom: 1.5rem;
    box-shadow:
        0 10px 25px rgba(0, 0, 0, 0.1),
        0 4px 10px rgba(0, 0, 0, 0.05),
        inset 0 1px 0 rgba(255, 255, 255, 0.6);
    backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
}

[data-theme="dark"] .current-track {
    background: linear-gradient(145deg, rgba(30, 41, 59, 0.95), rgba(51, 65, 85, 0.95));
    border: 1px solid rgba(71, 85, 105, 0.5);
    box-shadow:
        0 10px 25px rgba(0, 0, 0, 0.3),
        0 4px 10px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.current-track::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, #6366f1, #8b5cf6, #ec4899);
    opacity: 0.8;
}

.track-info {
    margin-bottom: 1.5rem;
    text-align: center;
}

.track-title {
    font-size: 1.4rem;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 0.5rem;
    line-height: 1.3;
    letter-spacing: -0.025em;
}

.track-author {
    color: var(--text-secondary);
    font-size: 1rem;
    font-weight: 500;
    opacity: 0.8;
}

.progress-container {
    margin: 1.5rem 0;
}

.progress-bar {
    width: 100%;
    height: 8px;
    background: rgba(148, 163, 184, 0.2);
    border-radius: 12px;
    overflow: hidden;
    margin: 0.75rem 0;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    transition: all 0.2s ease;
}

.progress-bar:hover {
    height: 10px;
    margin: 0.65rem 0;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #6366f1, #8b5cf6);
    width: 0%;
    transition: width 0.1s ease;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.4);
}

.progress-time {
    display: flex;
    justify-content: space-between;
    font-size: 0.9rem;
    color: var(--text-secondary);
    font-weight: 500;
    font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
}

/* Modern Control Buttons */
.controls {
    display: flex;
    gap: 1rem;
    justify-content: center;
    align-items: center;
    margin: 2rem 0 1.5rem 0;
}

.control-btn {
    background: linear-gradient(145deg, #ffffff, #f8fafc);
    color: #374151;
    border: 1px solid rgba(209, 213, 219, 0.8);
    padding: 0;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 1.2rem;
    font-weight: 600;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow:
        0 4px 6px rgba(0, 0, 0, 0.05),
        0 1px 3px rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.6);
    position: relative;
    overflow: hidden;
    min-width: unset;
}

[data-theme="dark"] .control-btn {
    background: linear-gradient(145deg, #374151, #4b5563);
    color: #f9fafb;
    border: 1px solid rgba(75, 85, 99, 0.8);
    box-shadow:
        0 4px 6px rgba(0, 0, 0, 0.2),
        0 1px 3px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

/* Primary play/pause button - only when active */
.control-btn.primary-active {
    background: linear-gradient(145deg, #6366f1, #8b5cf6);
    color: white;
    width: 56px;
    height: 56px;
    font-size: 1.4rem;
    border: none;
    box-shadow:
        0 8px 25px rgba(99, 102, 241, 0.3),
        0 4px 12px rgba(99, 102, 241, 0.2);
}

.control-btn:hover {
    transform: translateY(-2px) scale(1.05);
    box-shadow:
        0 8px 25px rgba(0, 0, 0, 0.1),
        0 4px 12px rgba(0, 0, 0, 0.08);
}

[data-theme="dark"] .control-btn:hover {
    box-shadow:
        0 8px 25px rgba(0, 0, 0, 0.3),
        0 4px 12px rgba(0, 0, 0, 0.2);
}

.control-btn.primary-active:hover {
    transform: translateY(-2px) scale(1.05);
    box-shadow:
        0 12px 35px rgba(99, 102, 241, 0.4),
        0 6px 16px rgba(99, 102, 241, 0.3);
}

.control-btn:active {
    transform: translateY(0) scale(0.98);
    transition: all 0.1s ease;
}

.control-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
    box-shadow:
        0 2px 4px rgba(0, 0, 0, 0.05),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

/* Control button icons */
.control-btn::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    opacity: 0.1;
    border-radius: 50%;
    background: currentColor;
    transition: all 0.3s ease;
}

.control-btn:hover::before {
    width: 40px;
    height: 40px;
    opacity: 0.1;
}

/* Modern Volume Control */
.volume-control {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin: 1.5rem 0;
    padding: 1rem;
    background: rgba(248, 250, 252, 0.5);
    border-radius: 16px;
    border: 1px solid rgba(226, 232, 240, 0.6);
    position: relative;
}

[data-theme="dark"] .volume-control {
    background: rgba(30, 41, 59, 0.5);
    border: 1px solid rgba(71, 85, 105, 0.4);
}

.volume-control span {
    font-size: 1.1rem;
    opacity: 0.7;
    min-width: fit-content;
}

.volume-slider {
    flex: 1;
    height: 6px;
    border-radius: 8px;
    background: rgba(148, 163, 184, 0.3);
    outline: none;
    cursor: pointer;
    appearance: none;
    position: relative;
    transition: all 0.2s ease;
}

.volume-slider:hover {
    height: 8px;
}

.volume-slider::-webkit-slider-thumb {
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(145deg, #6366f1, #8b5cf6);
    cursor: pointer;
    box-shadow:
        0 4px 12px rgba(99, 102, 241, 0.3),
        0 2px 6px rgba(99, 102, 241, 0.2);
    transition: all 0.2s ease;
    border: 2px solid white;
}

.volume-slider::-webkit-slider-thumb:hover {
    transform: scale(1.1);
    box-shadow:
        0 6px 20px rgba(99, 102, 241, 0.4),
        0 3px 10px rgba(99, 102, 241, 0.3);
}

.volume-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(145deg, #6366f1, #8b5cf6);
    cursor: pointer;
    border: 2px solid white;
    box-shadow:
        0 4px 12px rgba(99, 102, 241, 0.3),
        0 2px 6px rgba(99, 102, 241, 0.2);
    transition: all 0.2s ease;
}

.volume-slider::-moz-range-thumb:hover {
    transform: scale(1.1);
}

/* Volume visualization */
.volume-visualization {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg,
        rgba(99, 102, 241, 0.1) 0%,
        rgba(139, 92, 246, 0.1) 50%,
        rgba(236, 72, 153, 0.1) 100%);
    border-radius: 16px;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
}

.volume-visualization.active {
    opacity: 1;
}

#volume-display {
    font-weight: 600;
    font-size: 0.9rem;
    color: var(--text-primary);
    min-width: 40px;
    text-align: center;
    font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
}

.add-track {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    position: relative;
}

.add-track form {
    display: flex;
    gap: 0.75rem;
    align-items: center;
    position: relative;
}

.search-input-container {
    flex: 1;
    position: relative;
}

.search-input-container input {
    width: 100%;
    padding: 0.75rem 60px 0.75rem 0.75rem; /* Extra padding on right for dropdown */
    border: 1px solid var(--input-border);
    border-radius: 8px;
    background: var(--bg-primary);
    color: var(--text-primary);
    font-size: 0.95rem;
    position: relative;
}

.search-input-container input:focus {
    outline: none;
    border-color: var(--accent-color);
    box-shadow: 0 0 0 3px var(--focus-ring);
}

/* Text fade effect near dropdown */
.search-input-container::after {
    content: '';
    position: absolute;
    top: 1px;
    right: 50px;
    bottom: 1px;
    width: 20px;
    background: linear-gradient(to right, transparent, var(--bg-primary));
    pointer-events: none;
    border-radius: 0 7px 7px 0;
}

.source-dropdown {
    position: absolute;
    right: 1px;
    top: 1px;
    bottom: 1px;
    width: 48px;
    background: var(--bg-secondary);
    border: none;
    border-radius: 0 7px 7px 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-secondary);
    transition: all 0.2s ease;
    z-index: 10;
}

.source-dropdown:hover {
    background: rgba(99, 102, 241, 0.1);
    color: var(--text-primary);
}

.source-dropdown i {
    font-size: 1.1rem;
}

.source-options {
    position: absolute;
    top: 100%;
    right: 0;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    display: none;
    min-width: 160px;
    margin-top: 4px;
}

[data-theme="dark"] .source-options {
    background: var(--bg-secondary);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.source-options.show {
    display: block;
}

.source-option {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    cursor: pointer;
    transition: background 0.2s ease;
    color: var(--text-primary);
    border: none;
    background: none;
    width: 100%;
    text-align: left;
    font-size: 0.9rem;
    border-bottom: 1px solid var(--border-color);
}

.source-option:last-child {
    border-bottom: none;
}

.source-option:hover {
    background: rgba(99, 102, 241, 0.1);
}

.source-option.active {
    background: rgba(99, 102, 241, 0.15);
    color: var(--accent-color);
}

.source-option i {
    font-size: 1.1rem;
    width: 20px;
    text-align: center;
}

.source-option .source-label {
    font-weight: 500;
}


.add-track .btn {
    padding: 0.75rem 1.25rem;
    white-space: nowrap;
}

/* Search autocomplete styling */
.search-autocomplete {
    position: absolute;
    top: 100%;
    left: 0;
    right: 80px; /* Leave space for the button */
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-top: none;
    border-radius: 0 0 8px 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    max-height: 320px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
}

[data-theme="dark"] .search-autocomplete {
    background: var(--bg-secondary);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.search-suggestion {
    padding: 0.75rem 1rem;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
    transition: background 0.2s ease;
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.search-suggestion:last-child {
    border-bottom: none;
}

.search-suggestion:hover,
.search-suggestion.highlighted {
    background: rgba(99, 102, 241, 0.1);
}

.search-suggestion-thumbnail {
    width: 48px;
    height: 36px;
    border-radius: 6px;
    overflow: hidden;
    flex-shrink: 0;
    background: linear-gradient(145deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
    display: flex;
    align-items: center;
    justify-content: center;
}

.search-suggestion-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 6px;
}

.search-suggestion-thumbnail i {
    font-size: 1.2rem;
    color: var(--accent-color);
    opacity: 0.6;
}

.search-suggestion-info {
    flex: 1;
    min-width: 0;
}

.search-suggestion-title {
    font-weight: 500;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 0.25rem;
}

.search-suggestion-author {
    font-size: 0.85rem;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.search-suggestion-duration {
    font-size: 0.85rem;
    color: var(--text-secondary);
    font-family: monospace;
    flex-shrink: 0;
}

.btn[disabled] {
    opacity: 0.6;
    cursor: not-allowed;
    box-shadow: none;
}

.queue-list {
    max-height: 400px;
    overflow-y: auto;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--bg-primary);
}

.queue-list-offline .queue-item {
    opacity: 0.75;
}

.queue-item {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.75rem 1rem;
    border-bottom: 1px solid var(--border-color);
    transition: all 0.2s ease;
    cursor: move;
    position: relative;
}

.queue-item:hover {
    background: rgba(148, 163, 184, 0.1);
}

.queue-item:last-child {
    border-bottom: none;
}

/* Drag and drop styles */
.queue-item.dragging {
    opacity: 0.5;
    transform: rotate(5deg);
    z-index: 1000;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

.queue-item.drag-over {
    background: rgba(99, 102, 241, 0.1);
    border: 2px dashed #6366f1;
    transform: scale(1.02);
}

.queue-item.drop-target-above::before {
    content: '';
    position: absolute;
    top: -2px;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #6366f1, #8b5cf6);
    border-radius: 2px;
    z-index: 100;
}

.queue-item.drop-target-below::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #6366f1, #8b5cf6);
    border-radius: 2px;
    z-index: 100;
}

.queue-item .drag-handle {
    opacity: 0.3;
    font-size: 1rem;
    cursor: move;
    padding: 0.25rem;
    transition: opacity 0.2s ease;
}

.queue-item:hover .drag-handle {
    opacity: 0.7;
}

.queue-item .drag-handle:hover {
    opacity: 1;
}

.queue-item-info {
    flex: 1;
    min-width: 0;
}

.queue-item-title {
    font-weight: 500;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.queue-item-author {
    font-size: 0.85rem;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.queue-item-duration {
    font-size: 0.85rem;
    color: var(--text-secondary);
    font-family: monospace;
}

.btn-remove {
    background: var(--danger-color);
    color: white;
    border: none;
    padding: 0.4rem 0.6rem;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.8rem;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.35rem;
    line-height: 1;
}

.btn-remove:hover {
    background: #dc2626;
    transform: scale(1.05);
}

.btn-remove i {
    font-size: 0.85rem;
}

/* Modern Mode Controls */
.mode-controls {
    display: flex;
    gap: 0.75rem;
    justify-content: center;
    margin: 1.5rem 0 1rem 0;
}

.mode-btn {
    background: linear-gradient(145deg, rgba(248, 250, 252, 0.8), rgba(241, 245, 249, 0.8));
    color: var(--text-secondary);
    border: 1px solid rgba(203, 213, 225, 0.6);
    padding: 0.6rem 1rem;
    border-radius: 12px;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    box-shadow:
        0 2px 4px rgba(0, 0, 0, 0.05),
        inset 0 1px 0 rgba(255, 255, 255, 0.6);
    position: relative;
    overflow: hidden;
}

[data-theme="dark"] .mode-btn {
    background: linear-gradient(145deg, rgba(51, 65, 85, 0.8), rgba(71, 85, 105, 0.8));
    border: 1px solid rgba(100, 116, 139, 0.4);
    box-shadow:
        0 2px 4px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.mode-btn.active {
    background: linear-gradient(145deg, #6366f1, #8b5cf6);
    color: white;
    border-color: transparent;
    box-shadow:
        0 4px 12px rgba(99, 102, 241, 0.3),
        0 2px 6px rgba(99, 102, 241, 0.2);
    transform: translateY(-1px);
}

.mode-btn:hover {
    transform: translateY(-1px);
    box-shadow:
        0 6px 20px rgba(0, 0, 0, 0.1),
        0 3px 10px rgba(0, 0, 0, 0.05);
    border-color: rgba(99, 102, 241, 0.4);
}

[data-theme="dark"] .mode-btn:hover {
    box-shadow:
        0 6px 20px rgba(0, 0, 0, 0.3),
        0 3px 10px rgba(0, 0, 0, 0.2);
}

.mode-btn.active:hover {
    box-shadow:
        0 8px 25px rgba(99, 102, 241, 0.4),
        0 4px 12px rgba(99, 102, 241, 0.3);
}

.mode-btn:active {
    transform: translateY(0);
    transition: all 0.1s ease;
}

/* Mode button icons - Font Awesome */
.mode-btn i {
    font-size: 1rem;
    opacity: 0.8;
    margin-right: 0.5rem;
}

.mode-btn.active i {
    opacity: 1;
}

/* Toast notification styles for control messages */
.result {
    transition: opacity 0.3s ease, transform 0.3s ease, max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
}

.result.fade-out {
    opacity: 0;
    transform: translateY(-10px);
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    margin-top: 0;
    margin-bottom: 0;
    overflow: hidden;
}

.result.fade-in {
    opacity: 1;
    transform: translateY(0);
}

/* Hide empty result containers completely */
.result:empty {
    display: none;
}

.status-indicator {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    border-radius: 6px;
    font-size: 0.9rem;
    font-weight: 500;
    margin-bottom: 1rem;
}

.status-connected {
    background: rgba(16, 185, 129, 0.1);
    color: var(--success-color);
    border: 1px solid rgba(16, 185, 129, 0.3);
}

.status-disconnected {
    background: rgba(239, 68, 68, 0.1);
    color: var(--danger-color);
    border: 1px solid rgba(239, 68, 68, 0.3);
}

.empty-queue {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary);
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
}

.queue-offline-hint {
    margin-top: 1rem;
    font-size: 0.85rem;
    color: var(--text-secondary);
    text-align: center;
}

.queue-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
    gap: 0.75rem;
    margin: 1.25rem 0 0.5rem 0;
}

.queue-stat-card {
    background: rgba(148, 163, 184, 0.08);
    border: 1px solid rgba(148, 163, 184, 0.2);
    border-radius: 10px;
    padding: 0.75rem 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.queue-stat-label {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-secondary);
}

.queue-stat-value {
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--text-primary);
}

.queue-meta-footer {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 1rem;
}

@media (max-width: 1024px) {
    .music-grid {
        grid-template-columns: 1fr;
    }
}

[data-theme="dark"] .no-server-message {
    background: rgba(15, 23, 42, 0.9);
    border-color: rgba(148, 163, 184, 0.3);
}

@media (max-width: 768px) {
    .controls {
        gap: 0.5rem;
    }

    .control-btn {
        padding: 0.5rem 0.75rem;
        min-width: 70px;
        font-size: 0.8rem;
    }

    .mode-controls {
        flex-wrap: wrap;
    }
}
{% endblock %}

{% block content %}
<!-- No server selected message -->
<div id="no-server-message" class="no-server-message">
    <h3><i class="fas fa-music"></i> Select a Server</h3>
    <p>Please select a server from the sidebar to start managing music playback.</p>
</div>

<!-- Music controls (hidden by default) -->
<div id="music-controls" class="music-grid music-controls-hidden">
    <!-- Left Column: Player Controls -->
    <div class="music-section">
        <h3><i class="fas fa-play-circle"></i> Player Controls</h3>

        <div id="connection-status" class="status-indicator status-disconnected">
            <i class="fas fa-circle" style="color: #dc2626;"></i> Disconnected
        </div>

        <p id="connection-details" class="connection-details">
            Connect the bot to a voice channel to enable playback controls.
        </p>

        <div id="current-track" class="current-track" style="display: none;">
            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                <i class="fas fa-music" style="font-size: 1.1rem; color: var(--accent-color);"></i>
                <span style="font-weight: 600; color: var(--text-primary);">Now Playing</span>
            </div>

            <div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 1.5rem;">
                <div id="track-artwork" style="width: 80px; height: 80px; border-radius: 12px; overflow: hidden; flex-shrink: 0; background: linear-gradient(145deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); display: flex; align-items: center; justify-content: center;">
                    <i class="fas fa-music" style="font-size: 2rem; color: var(--accent-color); opacity: 0.6;"></i>
                </div>
                <div class="track-info" style="flex: 1; margin-bottom: 0;">
                    <div class="track-title" id="track-title">No track playing</div>
                    <div class="track-author" id="track-author"></div>
                </div>
            </div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="progress-time">
                    <span id="current-time">0:00</span>
                    <span id="total-time">0:00</span>
                </div>
            </div>
        </div>

        <div class="controls">
            <button type="button" id="play-pause-btn" class="control-btn" disabled
                    hx-post="/api/music/controls/play"
                    hx-include="[name='guild_id']"
                    hx-target="#control-result">
                <i class="fas fa-play"></i>
            </button>
            <button type="button" id="skip-btn" class="control-btn" disabled
                    hx-post="/api/music/controls/skip"
                    hx-include="[name='guild_id']"
                    hx-target="#control-result">
                <i class="fas fa-step-forward"></i>
            </button>
            <button type="button" id="stop-btn" class="control-btn" disabled
                    hx-post="/api/music/controls/stop"
                    hx-include="[name='guild_id']"
                    hx-target="#control-result">
                <i class="fas fa-stop"></i>
            </button>
        </div>

        <div class="volume-control">
            <div class="volume-visualization" id="volume-visualization"></div>
            <i class="fas fa-volume-up"></i>
            <input type="range" id="volume-slider" class="volume-slider"
                   min="0" max="150" value="50" disabled>
            <span id="volume-display">50%</span>
        </div>

        <div class="mode-controls">
            <button type="button" id="repeat-off" class="mode-btn active"
                    hx-post="/api/music/repeat"
                    hx-vals='{"mode": "off"}'
                    hx-include="[name='guild_id']"
                    hx-target="#control-result">
                <i class="fas fa-redo"></i> Off
            </button>
            <button type="button" id="repeat-track" class="mode-btn"
                    hx-post="/api/music/repeat"
                    hx-vals='{"mode": "track"}'
                    hx-include="[name='guild_id']"
                    hx-target="#control-result">
                <i class="fas fa-redo-alt"></i> Track
            </button>
            <button type="button" id="repeat-queue" class="mode-btn"
                    hx-post="/api/music/repeat"
                    hx-vals='{"mode": "queue"}'
                    hx-include="[name='guild_id']"
                    hx-target="#control-result">
                <i class="fas fa-redo"></i> Queue
            </button>
            <button type="button" id="shuffle-btn" class="mode-btn"
                    hx-post="/api/music/shuffle"
                    hx-include="[name='guild_id']"
                    hx-target="#control-result">
                <i class="fas fa-random"></i> Shuffle
            </button>
        </div>

        <div id="control-result" class="result"></div>
    </div>

    <!-- Right Column: Queue Management -->
    <div class="music-section">
        <h3><i class="fas fa-list"></i> Queue Management</h3>

        <div class="add-track">
            <form hx-post="/api/music/play" hx-target="#add-result">
                <input type="hidden" name="guild_id" value="" id="guild-id-input">
                <input type="hidden" name="source" value="ytsearch" id="search-source-input">

                <div class="search-input-container">
                    <input type="text" name="query" id="add-track-input" placeholder="Search YouTube..." required autocomplete="off">

                    <div class="source-dropdown" id="source-dropdown">
                        <i class="fab fa-youtube" id="current-source-icon"></i>
                    </div>

                    <div class="source-options" id="source-options">
                        <!-- Options will be populated dynamically -->
                    </div>
                </div>

                <button type="submit" class="btn" id="add-track-button"><i class="fas fa-plus"></i> Add to Queue</button>
            </form>
            <div class="search-autocomplete" id="search-autocomplete"></div>
        </div>

        <div id="add-result" class="result"></div>

        <div class="queue-stats">
            <div class="queue-stat-card">
                <span class="queue-stat-label">Tracks</span>
                <span class="queue-stat-value" id="queue-count">0</span>
            </div>
            <div class="queue-stat-card">
                <span class="queue-stat-label">Total Length</span>
                <span class="queue-stat-value" id="queue-duration">0:00</span>
            </div>
            <div class="queue-stat-card">
                <span class="queue-stat-label">Repeat</span>
                <span class="queue-stat-value" id="queue-repeat">Off</span>
            </div>
            <div class="queue-stat-card">
                <span class="queue-stat-label">Shuffle</span>
                <span class="queue-stat-value" id="queue-shuffle">Off</span>
            </div>
        </div>

        <div class="queue-meta-footer" id="queue-last-updated">Last updated — waiting…</div>

        <div id="queue-container">
            <div class="empty-queue">
                <p>Queue is empty</p>
                <p class="text-sm">Add some tracks to get started!</p>
            </div>
        </div>

        <div id="queue-result" class="result"></div>
    </div>
</div>

<!-- Hidden input for guild ID -->
<input type="hidden" name="guild_id" value="" id="guild-id-hidden">
{% endblock %}

{% block extra_scripts %}
<script>
let currentGuildId = null;
let latestStatus = null;
let musicWebSocket = null;
let progressUpdateInterval = null;
let reconnectTimeout = null;

const QUEUE_LOADING_HTML = '<div class="empty-queue"><p>Loading queue...</p></div>';
const QUEUE_SELECT_SERVER_HTML = '<div class="empty-queue"><p>Select a server to view the queue.</p></div>';

document.body.addEventListener('guild-changed', (event) => {
    const guildId = event.detail.guildId;
    const noServerMessage = document.getElementById('no-server-message');
    const musicControls = document.getElementById('music-controls');

    if (guildId) {
        noServerMessage.style.display = 'none';
        musicControls.style.display = 'grid';
        musicControls.classList.remove('music-controls-hidden');
        handleMusicGuildChange(guildId);
    } else {
        noServerMessage.style.display = 'block';
        musicControls.style.display = 'none';
        musicControls.classList.add('music-controls-hidden');
        handleMusicGuildChange('');
    }
});

function formatTime(ms) {
    const totalMs = Number(ms ?? 0);
    const minutes = Math.floor(totalMs / 60000);
    const seconds = Math.floor((totalMs % 60000) / 1000);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function extractYouTubeVideoId(url) {
    const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
    const match = url.match(regex);
    return match ? match[1] : null;
}

function connectWebSocket(guildId) {
    if (musicWebSocket) {
        musicWebSocket.close();
    }

    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/music/${guildId}`;

    musicWebSocket = new WebSocket(wsUrl);

    musicWebSocket.onopen = function(event) {
        console.log('Music WebSocket connected');
        setQueueFooter('Last updated — connected');
    };

    musicWebSocket.onmessage = function(event) {
        try {
            const message = JSON.parse(event.data);
            if (message.type === 'status_update' || message.type.endsWith('_update') || message.type.startsWith('track_') || message.type === 'queue_end' || message.type === 'queue_reorder') {
                latestStatus = message.data;
                updateUIFromStatus(message.data);

                // For queue reorder, add a small delay to show the reorder operation
                if (message.type === 'queue_reorder') {
                    setTimeout(() => {
                        refreshQueue();
                    }, 100);
                } else {
                    refreshQueue();
                }
            }
        } catch (error) {
            console.error('Error parsing WebSocket message:', error);
        }
    };

    musicWebSocket.onclose = function(event) {
        console.log('Music WebSocket disconnected');
        setQueueFooter('Last updated — disconnected');

        // Attempt to reconnect after 3 seconds if we still have a guild ID
        if (currentGuildId) {
            reconnectTimeout = setTimeout(() => {
                console.log('Attempting to reconnect WebSocket...');
                connectWebSocket(currentGuildId);
            }, 3000);
        }
    };

    musicWebSocket.onerror = function(error) {
        console.error('Music WebSocket error:', error);
    };

    // Send periodic ping to keep connection alive
    setInterval(() => {
        if (musicWebSocket && musicWebSocket.readyState === WebSocket.OPEN) {
            musicWebSocket.send(JSON.stringify({ type: 'ping' }));
        }
    }, 30000);
}

function updateUIFromStatus(status) {
    if (!status) return;

    const connectionStatus = document.getElementById('connection-status');
    const connectionDetails = document.getElementById('connection-details');
    if (status.connected) {
        connectionStatus.className = 'status-indicator status-connected';
        connectionStatus.innerHTML = '<i class="fas fa-circle" style="color: #10b981;"></i> Connected';
        connectionDetails.textContent = status.playing ? 'Playback in progress.' : 'Ready to play music.';
    } else {
        connectionStatus.className = 'status-indicator status-disconnected';
        connectionStatus.innerHTML = '<i class="fas fa-circle" style="color: #dc2626;"></i> Disconnected';
        connectionDetails.textContent = 'Connect the bot to a voice channel to enable playback controls.';
    }

    ['play-pause-btn', 'skip-btn', 'stop-btn'].forEach((id) => {
        const button = document.getElementById(id);
        if (button) {
            button.disabled = !status.connected;
        }
    });

    const volumeSlider = document.getElementById('volume-slider');
    volumeSlider.disabled = !status.connected;

    const addTrackInput = document.getElementById('add-track-input');
    const addTrackButton = document.getElementById('add-track-button');
    addTrackInput.disabled = !status.connected;
    addTrackButton.disabled = !status.connected;

    const currentTrackDiv = document.getElementById('current-track');
    const playPauseBtn = document.getElementById('play-pause-btn');

    if (status.current_track) {
        currentTrackDiv.style.display = 'block';
        document.getElementById('track-title').textContent = status.current_track.title;
        document.getElementById('track-author').textContent = status.current_track.author;
        document.getElementById('current-time').textContent = formatTime(status.current_track.position);
        document.getElementById('total-time').textContent = formatTime(status.current_track.duration);

        const progress = status.current_track.duration
            ? Math.min(100, (status.current_track.position / status.current_track.duration) * 100)
            : 0;
        document.getElementById('progress-fill').style.width = `${progress}%`;

        // Update track artwork - try to extract from YouTube URL or use default
        const trackArtwork = document.getElementById('track-artwork');
        if (status.current_track.uri && status.current_track.uri.includes('youtube')) {
            const videoId = extractYouTubeVideoId(status.current_track.uri);
            if (videoId) {
                trackArtwork.innerHTML = `<img src="https://img.youtube.com/vi/${videoId}/mqdefault.jpg" style="width: 100%; height: 100%; object-fit: cover;" alt="Track artwork">`;
            } else {
                trackArtwork.innerHTML = '<i class="fas fa-music" style="font-size: 2rem; color: var(--accent-color); opacity: 0.6;"></i>';
            }
        } else {
            trackArtwork.innerHTML = '<i class="fas fa-music" style="font-size: 2rem; color: var(--accent-color); opacity: 0.6;"></i>';
        }
    } else {
        currentTrackDiv.style.display = 'none';
        document.getElementById('progress-fill').style.width = '0%';
    }

    // Update play/pause button
    if (playPauseBtn) {
        playPauseBtn.classList.remove('primary-active');

        // Check if music is actively playing (not paused)
        const isActivelyPlaying = status.playing && !status.paused;

        if (isActivelyPlaying) {
            // Music is actively playing - show pause button in purple
            playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
            playPauseBtn.classList.add('primary-active');
            playPauseBtn.setAttribute('hx-post', '/api/music/controls/pause');
        } else if (status.current_track) {
            // Music exists but is paused/stopped - show play button in purple
            playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
            playPauseBtn.classList.add('primary-active');
            playPauseBtn.setAttribute('hx-post', '/api/music/controls/play');
        } else {
            // No music loaded - show play button in gray
            playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
            playPauseBtn.setAttribute('hx-post', '/api/music/controls/play');
        }

        // Ensure HTMX attributes are set properly
        playPauseBtn.setAttribute('hx-include', '[name="guild_id"]');
        playPauseBtn.setAttribute('hx-target', '#control-result');

        // Re-process this element with HTMX to update the event handlers
        if (window.htmx) {
            window.htmx.process(playPauseBtn);
        }
    }

    volumeSlider.value = status.volume;
    document.getElementById('volume-display').textContent = `${status.volume}%`;

    document.querySelectorAll('.mode-btn').forEach((btn) => btn.classList.remove('active'));
    const repeatButton = document.getElementById(`repeat-${status.repeat_mode}`);
    if (repeatButton) {
        repeatButton.classList.add('active');
    }
    const shuffleButton = document.getElementById('shuffle-btn');
    shuffleButton.classList.toggle('active', Boolean(status.shuffle_enabled));

    updateQueueStats(status);

    // Start/stop progress updates based on playback state
    if (status.playing && !status.paused && status.current_track) {
        startProgressUpdates();
    } else {
        stopProgressUpdates();
    }
}

async function refreshQueue(showLoading = false) {
    if (!currentGuildId) return;

    const queueContainer = document.getElementById('queue-container');
    if (!queueContainer) return;

    if (showLoading) {
        queueContainer.innerHTML = QUEUE_LOADING_HTML;
        setQueueFooter('Last updated — syncing…');
    }

    const status = latestStatus;
    if (!status) {
        return;
    }

    if (!status.connected) {
        queueContainer.innerHTML = renderOfflineQueue(status);
        updateQueueTimestamp();
        return;
    }

    const html = renderConnectedQueue(status);
    queueContainer.innerHTML = html;
    if (window.htmx) {
        htmx.process(queueContainer);
    }

    // Initialize drag and drop after queue is rendered with a slight delay
    setTimeout(() => {
        initializeDragAndDrop();
    }, 50);

    updateQueueTimestamp();
}

// Drag and drop functionality - Global state
let draggedElement = null;
let draggedFromPosition = null;
let isDragAndDropInitialized = false;

function initializeDragAndDrop() {
    if (isDragAndDropInitialized) return;

    const queueContainer = document.getElementById('queue-container');
    if (!queueContainer) return;

    isDragAndDropInitialized = true;

    queueContainer.addEventListener('dragstart', function(e) {
        const queueItem = e.target.closest('.queue-item');
        if (!queueItem) return;

        draggedElement = queueItem;
        draggedFromPosition = parseInt(queueItem.dataset.position);
        queueItem.classList.add('dragging');

        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', queueItem.outerHTML);
    });

    queueContainer.addEventListener('dragend', function(e) {
        const queueItem = e.target.closest('.queue-item');
        if (queueItem && draggedElement) {
            queueItem.classList.remove('dragging');
            // Remove all drop indicators
            document.querySelectorAll('.queue-item').forEach(item => {
                item.classList.remove('drag-over', 'drop-target-above', 'drop-target-below');
            });
            draggedElement = null;
            draggedFromPosition = null;
        }
    });

    queueContainer.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';

        const queueItem = e.target.closest('.queue-item');
        if (!queueItem || queueItem === draggedElement) return;

        // Remove previous indicators
        document.querySelectorAll('.queue-item').forEach(item => {
            item.classList.remove('drag-over', 'drop-target-above', 'drop-target-below');
        });

        const rect = queueItem.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;

        if (e.clientY < midpoint) {
            queueItem.classList.add('drop-target-above');
        } else {
            queueItem.classList.add('drop-target-below');
        }
    });

    queueContainer.addEventListener('drop', function(e) {
        e.preventDefault();

        const targetItem = e.target.closest('.queue-item');
        if (!targetItem || !draggedElement || targetItem === draggedElement) return;

        const targetPosition = parseInt(targetItem.dataset.position);
        const rect = targetItem.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;

        let dropToPosition;
        if (e.clientY < midpoint) {
            // Drop above target
            dropToPosition = targetPosition;
        } else {
            // Drop below target
            dropToPosition = targetPosition + 1;
        }

        // Adjust for removed element
        if (draggedFromPosition < dropToPosition) {
            dropToPosition--;
        }

        if (draggedFromPosition !== dropToPosition) {
            // Add visual feedback during reordering
            const queueList = document.querySelector('.queue-list');
            if (queueList) {
                queueList.style.opacity = '0.7';
                queueList.style.pointerEvents = 'none';
            }

            reorderQueueTrack(draggedFromPosition, dropToPosition).then(() => {
                // Restore interactivity after a brief moment
                setTimeout(() => {
                    if (queueList) {
                        queueList.style.opacity = '1';
                        queueList.style.pointerEvents = 'auto';
                    }
                }, 200);
            }).catch((error) => {
                console.error('Reorder failed:', error);
                // Restore interactivity immediately on error
                if (queueList) {
                    queueList.style.opacity = '1';
                    queueList.style.pointerEvents = 'auto';
                }
            });
        }

        // Clean up
        document.querySelectorAll('.queue-item').forEach(item => {
            item.classList.remove('drag-over', 'drop-target-above', 'drop-target-below');
        });
    });
}

async function reorderQueueTrack(fromPosition, toPosition) {
    if (!currentGuildId) return;

    try {
        const formData = new FormData();
        formData.append('guild_id', currentGuildId);
        formData.append('from_position', fromPosition);
        formData.append('to_position', toPosition);

        const response = await fetch('/api/music/queue/reorder', {
            method: 'POST',
            body: formData
        });

        const result = await response.json();

        if (!result.success) {
            console.error('Failed to reorder queue:', result.error);
        }
    } catch (error) {
        console.error('Error reordering queue:', error);
    }
}

// Volume visualization functionality
let volumeVisualizationTimeout;

function showVolumeVisualization() {
    const visualization = document.getElementById('volume-visualization');
    if (visualization) {
        visualization.classList.add('active');

        clearTimeout(volumeVisualizationTimeout);
        volumeVisualizationTimeout = setTimeout(() => {
            visualization.classList.remove('active');
        }, 1500);
    }
}

document.getElementById('volume-slider').addEventListener('input', function(e) {
    const volume = e.target.value;
    document.getElementById('volume-display').textContent = `${volume}%`;

    // Show volume visualization
    showVolumeVisualization();

    clearTimeout(this.volumeTimeout);
    this.volumeTimeout = setTimeout(() => {
        if (currentGuildId) {
            const formData = new FormData();
            formData.append('guild_id', currentGuildId);
            formData.append('volume', volume);

            fetch('/api/music/volume', {
                method: 'POST',
                body: formData
            });
        }
    }, 300);
});

function updateQueueStats(status) {
    document.getElementById('queue-count').textContent = status.queue.length;
    document.getElementById('queue-duration').textContent = formatTime(status.queue_duration);

    const repeatLabel = { off: 'Off', track: 'Track', queue: 'Queue' }[status.repeat_mode] || 'Off';
    document.getElementById('queue-repeat').textContent = repeatLabel;
    document.getElementById('queue-shuffle').textContent = status.shuffle_enabled ? 'On' : 'Off';
}

function escapeHtml(value) {
    if (typeof value !== 'string') {
        return String(value ?? '');
    }
    return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

function renderConnectedQueue(status) {
    const queue = Array.isArray(status.queue) ? status.queue : [];

    if (queue.length === 0) {
        return '<div class="empty-queue"><p>Queue is empty</p><p class="text-sm">Add some tracks to get started!</p></div>';
    }

    const rawGuildId = String(currentGuildId ?? '');
    const guildId = rawGuildId.replace(/[^0-9]/g, '') || rawGuildId;
    let html = '<div class="queue-list" id="sortable-queue">';
    queue.forEach((track, index) => {
        const title = escapeHtml(track.title ?? track.track_title ?? `Track ${index + 1}`);
        const author = escapeHtml(track.author ?? track.track_author ?? 'Unknown artist');
        const duration = formatTime(track.duration ?? track.track_duration ?? 0);
        const position = index;
        const hxVals = `{"guild_id": "${guildId}", "position": ${position}}`;

        html += `
            <div class="queue-item" data-position="${position}" draggable="true">
                <div class="drag-handle">
                    <i class="fas fa-grip-vertical"></i>
                </div>
                <div class="queue-item-info">
                    <div class="queue-item-title">${title}</div>
                    <div class="queue-item-author">${author}</div>
                </div>
                <div class="queue-item-duration">${duration}</div>
                <button type="button"
                        class="btn-remove"
                        hx-post="/api/music/queue/remove"
                        hx-vals='${hxVals}'
                        hx-target="#queue-result"
                        aria-label="Remove track">
                    <i class="fa-solid fa-trash-can icon icon-sm" aria-hidden="true"></i>
                </button>
            </div>
        `;
    });

    html += '</div>';
    return html;
}

function renderOfflineQueue(status) {
    if (!status || !status.queue || status.queue.length === 0) {
        return '<div class="empty-queue"><p>Queue is empty</p><p class="text-sm">Add some tracks to get started!</p></div>';
    }

    let html = '<div class="queue-list queue-list-offline">';
    status.queue.forEach((track, index) => {
        const title = escapeHtml(track.title ?? track.track_title ?? `Track ${index + 1}`);
        const author = escapeHtml(track.author ?? track.track_author ?? 'Unknown artist');
        const duration = formatTime(track.duration ?? track.track_duration ?? 0);

        html += `
            <div class="queue-item">
                <div class="queue-item-info">
                    <div class="queue-item-title">${title}</div>
                    <div class="queue-item-author">${author}</div>
                </div>
                <div class="queue-item-duration">${duration}</div>
            </div>
        `;
    });
    html += '</div><div class="queue-offline-hint">Connect the bot to a voice channel to manage this queue live.</div>';
    return html;
}

function setQueueFooter(message) {
    const footer = document.getElementById('queue-last-updated');
    if (footer) {
        footer.textContent = message;
    }
}

function updateQueueTimestamp() {
    const now = new Date();
    const formatted = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    setQueueFooter(`Last updated — ${formatted}`);
}

function startProgressUpdates() {
    if (progressUpdateInterval) {
        clearInterval(progressUpdateInterval);
    }

    progressUpdateInterval = setInterval(() => {
        if (latestStatus && latestStatus.current_track && latestStatus.playing && !latestStatus.paused) {
            // Only update progress when actually playing (not paused)
            const currentTime = latestStatus.current_track.position + 1000; // Add 1 second
            latestStatus.current_track.position = currentTime;

            document.getElementById('current-time').textContent = formatTime(currentTime);

            const progress = latestStatus.current_track.duration
                ? Math.min(100, (currentTime / latestStatus.current_track.duration) * 100)
                : 0;
            document.getElementById('progress-fill').style.width = `${progress}%`;
        }
    }, 1000);
}

function stopProgressUpdates() {
    if (progressUpdateInterval) {
        clearInterval(progressUpdateInterval);
        progressUpdateInterval = null;
    }
}

function resetMusicView() {
    latestStatus = null;
    const connectionStatus = document.getElementById('connection-status');
    connectionStatus.className = 'status-indicator status-disconnected';
    connectionStatus.innerHTML = '<i class="fas fa-circle" style="color: #dc2626;"></i> Disconnected';

    const connectionDetails = document.getElementById('connection-details');
    connectionDetails.textContent = 'Connect the bot to a voice channel to enable playback controls.';

    document.getElementById('current-track').style.display = 'none';
    document.getElementById('progress-fill').style.width = '0%';

    ['play-pause-btn', 'skip-btn', 'stop-btn'].forEach((id) => {
        const button = document.getElementById(id);
        if (button) {
            button.disabled = true;
            if (id === 'play-pause-btn') {
                button.classList.remove('primary-active');
                button.innerHTML = '<i class="fas fa-play"></i>';
            }
        }
    });

    document.getElementById('volume-slider').disabled = true;
    document.getElementById('volume-display').textContent = '50%';
    document.getElementById('volume-slider').value = 50;

    document.getElementById('add-track-input').disabled = true;
    document.getElementById('add-track-button').disabled = true;

    document.getElementById('queue-count').textContent = '0';
    document.getElementById('queue-duration').textContent = '0:00';
    document.getElementById('queue-repeat').textContent = 'Off';
    document.getElementById('queue-shuffle').textContent = 'Off';
    setQueueFooter('Last updated — waiting…');
}

function handleMusicGuildChange(guildId) {
    currentGuildId = guildId;

    // Clear reconnect timeout if any
    if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
        reconnectTimeout = null;
    }

    // Close existing WebSocket connection
    if (musicWebSocket) {
        musicWebSocket.close();
        musicWebSocket = null;
    }

    // Stop progress updates
    stopProgressUpdates();

    const queueContainer = document.getElementById('queue-container');

    if (currentGuildId) {
        document.getElementById('guild-id-input').value = currentGuildId;
        document.getElementById('guild-id-hidden').value = currentGuildId;
        document.querySelectorAll('input[name="guild_id"]').forEach((input) => {
            input.value = currentGuildId;
        });

        if (queueContainer) {
            queueContainer.innerHTML = QUEUE_LOADING_HTML;
        }

        document.getElementById('add-track-input').disabled = true;
        document.getElementById('add-track-button').disabled = true;
        setQueueFooter('Last updated — connecting…');

        // Connect to WebSocket for real-time updates
        connectWebSocket(currentGuildId);

        // Initialize drag and drop
        initializeDragAndDrop();

        // Initialize search autocomplete and source selector
        initializeSearchAutocomplete();
        initializeSourceSelector();

        // Start progress updates for current track
        startProgressUpdates();
    } else {
        document.getElementById('guild-id-input').value = '';
        document.getElementById('guild-id-hidden').value = '';
        document.querySelectorAll('input[name="guild_id"]').forEach((input) => {
            input.value = '';
        });

        if (queueContainer) {
            queueContainer.innerHTML = QUEUE_SELECT_SERVER_HTML;
        }

        resetMusicView();
    }
}

// Mode button event handlers (no longer needed since WebSocket handles updates automatically)

window.addEventListener('beforeunload', () => {
    stopProgressUpdates();
    if (musicWebSocket) {
        musicWebSocket.close();
    }
    if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
    }
});

// Search autocomplete functionality
let searchTimeout;
let currentHighlightedIndex = -1;
let suggestions = [];

function initializeSearchAutocomplete() {
    const searchInput = document.getElementById('add-track-input');
    const autocompleteDiv = document.getElementById('search-autocomplete');

    if (!searchInput || !autocompleteDiv) return;

    searchInput.addEventListener('input', function(e) {
        const query = e.target.value.trim();

        clearTimeout(searchTimeout);

        if (query.length < 2) {
            hideAutocomplete();
            return;
        }

        // Don't show suggestions for URLs
        if (query.startsWith('http://') || query.startsWith('https://') || query.startsWith('www.')) {
            hideAutocomplete();
            return;
        }

        searchTimeout = setTimeout(() => {
            fetchSuggestions(query);
        }, 300);
    });

    searchInput.addEventListener('keydown', function(e) {
        const autocompleteDiv = document.getElementById('search-autocomplete');
        if (autocompleteDiv.style.display === 'none') return;

        switch (e.key) {
            case 'ArrowDown':
                e.preventDefault();
                currentHighlightedIndex = Math.min(currentHighlightedIndex + 1, suggestions.length - 1);
                updateHighlight();
                break;
            case 'ArrowUp':
                e.preventDefault();
                currentHighlightedIndex = Math.max(currentHighlightedIndex - 1, -1);
                updateHighlight();
                break;
            case 'Enter':
                if (currentHighlightedIndex >= 0 && currentHighlightedIndex < suggestions.length) {
                    e.preventDefault();
                    selectSuggestion(suggestions[currentHighlightedIndex]);
                }
                break;
            case 'Escape':
                hideAutocomplete();
                break;
        }
    });

    searchInput.addEventListener('blur', function() {
        // Small delay to allow clicking on suggestions
        setTimeout(() => {
            hideAutocomplete();
        }, 150);
    });

    searchInput.addEventListener('focus', function() {
        if (suggestions.length > 0 && this.value.trim().length >= 2) {
            showAutocomplete();
        }
    });
}

async function fetchSuggestions(query) {
    try {
        const sourceInput = document.getElementById('search-source-input');
        const source = sourceInput ? sourceInput.value : 'ytsearch';

        const response = await fetch(`/api/music/search/suggestions?query=${encodeURIComponent(query)}&source=${encodeURIComponent(source)}`);
        const data = await response.json();

        suggestions = data;
        displaySuggestions(data);
    } catch (error) {
        console.error('Error fetching suggestions:', error);
        hideAutocomplete();
    }
}

function displaySuggestions(suggestions) {
    const autocompleteDiv = document.getElementById('search-autocomplete');

    if (!suggestions || suggestions.length === 0) {
        hideAutocomplete();
        return;
    }

    let html = '';
    suggestions.forEach((suggestion, index) => {
        // Determine fallback icon based on source
        const sourceIcons = {
            'ytsearch': 'fab fa-youtube',
            'ytmsearch': 'fab fa-youtube',
            'spsearch': 'fab fa-spotify',
            'amsearch': 'fab fa-apple',
            'scsearch': 'fab fa-soundcloud',
            'dzsearch': 'fas fa-music'
        };

        const fallbackIcon = sourceIcons[suggestion.source] || 'fas fa-music';

        const thumbnailHtml = suggestion.thumbnail
            ? `<img src="${suggestion.thumbnail}" alt="Track thumbnail" loading="lazy" onerror="this.parentElement.innerHTML='<i class=\\"${fallbackIcon}\\"></i>'">`
            : `<i class="${fallbackIcon}"></i>`;

        html += `
            <div class="search-suggestion" data-index="${index}" onclick="selectSuggestion(${JSON.stringify(suggestion).replace(/"/g, '&quot;')})">
                <div class="search-suggestion-thumbnail">
                    ${thumbnailHtml}
                </div>
                <div class="search-suggestion-info">
                    <div class="search-suggestion-title">${escapeHtml(suggestion.title)}</div>
                    <div class="search-suggestion-author">${escapeHtml(suggestion.author)}</div>
                </div>
                <div class="search-suggestion-duration">${suggestion.duration}</div>
            </div>
        `;
    });

    autocompleteDiv.innerHTML = html;
    showAutocomplete();
    currentHighlightedIndex = -1;
}

function selectSuggestion(suggestion) {
    const searchInput = document.getElementById('add-track-input');
    searchInput.value = suggestion.display;
    hideAutocomplete();

    // Optionally trigger the form submission
    // searchInput.closest('form').querySelector('button[type="submit"]').click();
}

function updateHighlight() {
    const suggestionElements = document.querySelectorAll('.search-suggestion');

    suggestionElements.forEach((element, index) => {
        element.classList.toggle('highlighted', index === currentHighlightedIndex);
    });

    // Scroll highlighted element into view
    if (currentHighlightedIndex >= 0 && currentHighlightedIndex < suggestionElements.length) {
        suggestionElements[currentHighlightedIndex].scrollIntoView({
            block: 'nearest'
        });
    }
}

function showAutocomplete() {
    const autocompleteDiv = document.getElementById('search-autocomplete');
    autocompleteDiv.style.display = 'block';
}

function hideAutocomplete() {
    const autocompleteDiv = document.getElementById('search-autocomplete');
    autocompleteDiv.style.display = 'none';
    currentHighlightedIndex = -1;
    suggestions = [];
}

// Close autocomplete when clicking outside
document.addEventListener('click', function(e) {
    const addTrackDiv = e.target.closest('.add-track');
    if (!addTrackDiv) {
        hideAutocomplete();
    }
});

// Source dropdown functionality
let availableSources = [];

async function loadAvailableSources() {
    try {
        const response = await fetch('/api/music/sources');
        const sources = await response.json();
        availableSources = sources;
        populateSourceOptions(sources);
    } catch (error) {
        console.error('Error loading sources:', error);
        // Fallback to YouTube only
        availableSources = [{
            id: 'ytsearch',
            name: 'YouTube',
            icon: 'fab fa-youtube',
            available: true
        }];
        populateSourceOptions(availableSources);
    }
}

function populateSourceOptions(sources) {
    const optionsContainer = document.getElementById('source-options');
    if (!optionsContainer) return;

    let html = '';
    const firstSource = sources[0]; // All sources are available now

    sources.forEach((source, index) => {
        const isFirst = index === 0;
        const activeClass = isFirst ? ' active' : '';

        html += `
            <button type="button"
                    class="source-option${activeClass}"
                    data-source="${source.id}"
                    data-icon="${source.icon}">
                <i class="${source.icon}"></i>
                <span class="source-label">${source.name}</span>
            </button>
        `;
    });

    optionsContainer.innerHTML = html;

    // Set default source to first available
    if (firstSource) {
        const sourceInput = document.getElementById('search-source-input');
        const currentIcon = document.getElementById('current-source-icon');
        const searchInput = document.getElementById('add-track-input');

        if (sourceInput) {
            sourceInput.value = firstSource.id;
        }

        if (currentIcon) {
            currentIcon.className = firstSource.icon;
        }

        if (searchInput) {
            searchInput.placeholder = `Search ${firstSource.name}...`;
        }
    }

    // Re-initialize event handlers
    initializeSourceDropdownEvents();
}

function initializeSourceDropdownEvents() {
    const dropdown = document.getElementById('source-dropdown');
    const options = document.getElementById('source-options');
    const sourceInput = document.getElementById('search-source-input');
    const currentIcon = document.getElementById('current-source-icon');

    // Toggle dropdown on click
    if (dropdown) {
        dropdown.removeEventListener('click', toggleDropdown); // Remove existing listener
        dropdown.addEventListener('click', toggleDropdown);
    }

    // Handle option selection
    const sourceOptions = document.querySelectorAll('.source-option');
    sourceOptions.forEach(option => {
        option.addEventListener('click', function(e) {
            e.stopPropagation();

            // Remove active class from all options
            document.querySelectorAll('.source-option').forEach(opt => opt.classList.remove('active'));

            // Add active class to clicked option
            this.classList.add('active');

            // Update hidden input value
            const source = this.dataset.source;
            const icon = this.dataset.icon;

            if (sourceInput) {
                sourceInput.value = source;
            }

            // Update dropdown icon
            if (currentIcon && icon) {
                currentIcon.className = icon;
            }

            // Update placeholder text based on source
            const searchInput = document.getElementById('add-track-input');
            const selectedSource = availableSources.find(s => s.id === source);
            if (searchInput && selectedSource) {
                searchInput.placeholder = `Search ${selectedSource.name}...`;
            }

            // Hide dropdown
            options.classList.remove('show');

            // Clear current suggestions since source changed
            hideAutocomplete();
        });
    });
}

function toggleDropdown(e) {
    e.stopPropagation();
    const options = document.getElementById('source-options');
    options.classList.toggle('show');
}

function initializeSourceSelector() {
    // Load sources from server
    loadAvailableSources();

    // Close dropdown when clicking outside
    document.addEventListener('click', function(e) {
        const options = document.getElementById('source-options');
        if (options && !e.target.closest('.search-input-container')) {
            options.classList.remove('show');
        }
    });
}

// Initialize autocomplete when page loads
document.addEventListener('DOMContentLoaded', function() {
    initializeSearchAutocomplete();
    initializeSourceSelector();
    initializeToastNotifications();
});

// Toast notification fade-out functionality
function initializeToastNotifications() {
    // Create a MutationObserver to watch for changes in control result divs
    const observeControlResults = (selector) => {
        const targetElement = document.querySelector(selector);
        if (!targetElement) return;

        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                    // Check if any added nodes contain text content (indicating a new message)
                    const hasTextContent = Array.from(mutation.addedNodes).some(node =>
                        (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) ||
                        (node.nodeType === Node.ELEMENT_NODE && node.textContent.trim())
                    );

                    if (hasTextContent) {
                        fadeInAndScheduleFadeOut(targetElement);
                    }
                }
            });
        });

        observer.observe(targetElement, {
            childList: true,
            subtree: true
        });
    };

    // Observe both control result areas
    observeControlResults('#control-result');
    observeControlResults('#add-result');
    observeControlResults('#queue-result');
}

function fadeInAndScheduleFadeOut(element) {
    // Clear any existing fade-out timeout
    if (element.fadeTimeout) {
        clearTimeout(element.fadeTimeout);
    }

    // Remove any existing fade classes
    element.classList.remove('fade-out');
    element.classList.add('fade-in');

    // Schedule fade-out after 3 seconds
    element.fadeTimeout = setTimeout(() => {
        element.classList.remove('fade-in');
        element.classList.add('fade-out');

        // After fade-out animation completes, clear the content
        setTimeout(() => {
            if (element.classList.contains('fade-out')) {
                element.innerHTML = '';
                element.classList.remove('fade-out');
                element.classList.remove('show');
                element.style.display = 'none';
            }
        }, 300); // Match the CSS transition duration

        element.fadeTimeout = null;
    }, 3000);
}

// HTMX requests will trigger WebSocket broadcasts automatically from the server
</script>
{% endblock %}
